# 🍝 Philosophers

Edsger Dijkstra의 유명한 '식사하는 철학자 문제(Dining Philosophers Problem)'를 기반으로 동시성 프로그래밍(Concurrent Programming)을 학습하고 동기화 문제 해결하기.

## ℹ️ 설명

- 하나 이상의 철학자가 원형 테이블에 앉아 있다.
- 테이블 중앙에 큰 스파게티 그릇이 있다.
- 스파게티는 두 개의 포크를 사용해야만 먹을 수 있다.
- 포크는 철학자의 수만큼 있다.
- 각 철학자는 번갈아 가며 먹고, 자고, 생각한다.
- 철학자가 일정 시간 내에 식자를 하지 않으면 굶어 죽는다.
- 철학자가 굶어 죽으면 시뮬레이션은 종료된다.
- 철학자들은 서로 대화하지 않는다.
- 철학자들은 다른 철학자가 죽기 직전인지 모른다.
- 철학자들이 죽지 않도록 해야 한다.
- 프로그램은 데이터 레이스가 발생하지 않아야 한다.(컴파일시 -fsanitize=thread 옵션으로 확인 가능)

### 매개변수

- `philo_num`: 철학자의 수이자 포크의 수.
- `time_to_die`: 철학자가 식사를 하고 나서 살아남을 수 있는 시간(밀리초 단위). 만약 철학자가 마지막 식사 이후 또는 시뮬레이션 시작 이후 `time_to_die` 밀리초 내에 식사를 시작하지 않으면, 그 철학자는 굶어 죽는다
- `time_to_eat`: 철학자가 식사를 끝내는 데 걸리는 시간(밀리초 단위). 그 시간 동안 철학자는 두 개의 포크를 손에 들고 있어야 한다.
- `time_to_sleep`: 철학자가 잠을 자는 시간(밀리초 단위)
- `must_eat`: (선택 사항) 모든 철학자가 최소한 해당 횟수만큼 식사했을 때 프로그램을 종료할 수 있게 한다. 이 인자가 지정되지 않으면, 철학자가 죽을 때까지 시뮬레이션이 계속된다.

### 출력 형식

```shell
[timestamp_in_ms] [X] has taken a fork
[timestamp_in_ms] [X] is eating
[timestamp_in_ms] [X] is sleeping
[timestamp_in_ms] [X] is thinking
[timestamp_in_ms] [X] died
```

- timestamp_in_ms는 현재 밀리초 단위의 타임스탬프로 교체되어야 하고, X는 철학자의 번호로 교체되어야 한다.
- 철학자가 사망했을 때, 해당 메시지는 실제 사망 후 10ms 이내에 출력되어야 한다.

<br>

## ⌨️ 실행방법

1. 프로그램 설치 및 루트 디렉토리로 이동

```shell
git clone https://github.com/GCgang/philosophers.git && cd philosophers

```

2. 프로그램 컴파일

```shell
make
```

3. 프로그램 실행

```shell
./philo [philo_num] [time_to_die] [time_to_eat] [time_to_sleep] [must_eat (선택)]
```

4. 실행 예시 1: 철학자가 모두 살아남는 경우

```shell
/philo 4 800 200 200 5
```

- 4명의 철학자가 각 5번 식사를 완료하면 시뮬레이션 종료.
- 철학자는 800ms 이내에 식사를 시작하지 않으면 굶어 죽는다.
- 각 철학자는 200ms 동안 식사하고 200ms 동안 잠을 잔다.

<br>

## ✅ 데드락 방지 및 데이터 레이스 예방

### `데드락(Deadlock)`

문제에서 데드락이 발생할 수 있는 전형적인 경우는 모든 철학자가 동시에 포크 하나만 집어 서로 다른 포크를 기다리는 상황이다. 이 경우 모든 철학자가 교착 상태에 빠지게 되어 시뮬레이션이 멈추는 문제가 발생한다.

### `데드락 조건`

데드락이 발생하기 위해서는 다음 4가지 조건이 동시에 성립해야 한다.

1. 상호 배제(Mutual Exclusion):

- 포크는 동시에 하나의 철학자만 사용할 수 있다. 한 철학자가 포크를 집고 있으면 다른 철학자는 그 포크를 사용할 수 없기 때문에, 상호 배제 조건이 성립한다.

2. 점유 대기(Hold and Wait):

- 철학자는 하나의 포크를 이미 점유한 상태에서 다른 포크를 얻기 위해 기다린다. 예를 들어, 철학자가 왼쪽 포크를 들고 오른쪽 포크를 기다리는 상황에서 점유 대기 조건이 성립한다.

3. 비선점(No Preemption):

- 철학자는 다른 철학자가 포크를 강제로 빼앗을 수 없다. 포크를 사용하고 있는 철학자가 스스로 포크를 내려놓을 때까지 다른 철학자는 그 포크를 사용할 수 없기 때문에, 비선점 조건이 성립한다.

4. 순환 대기(Circular Wait):

- 철철학자들이 원형으로 배치되어 각 철학자가 서로 다른 철학자의 포크를 기다리고 있다. 즉, 철학자 1은 철학자 2의 포크를 기다리고, 철학자 2는 철학자 3의 포크를 기다리는 식으로 원형으로 대기하는 구조이기 때문에 순환 대기 조건도 성립한다.

### `데드락 방지`

- 철학자 번호를 홀수와 짝수로 나누어 포크를 잡는 순서를 다르게 조정.
- 짝수 번호의 철학자는 먼저 포크를 집도록 하고, 왼쪽 포크를 먼저 집고 오른쪽 포크를 그다음에 집는다.
- 홀수 번호의 철학자는 일정 시간(먹는시간의 80%로 설정) 동안 대기한 후 포크를 집는다.
- 이렇게 하면, 짝수 철학자가 먼저 왼쪽과 오른쪽 포크를 들고 식사를 시작하게 되므로, 짝수 철학자들이 포크를 모두 사용하고 내려놓은 후에 홀수 철학자들이 포크를 들고 식사할 수 있다. 이로 인해 동시에 포크를 들려고 하지 않게 되어, 철학자들이 서로의 포크를 끝없이 기다리는 상황인 `순환 대기(Circular Wait)`를 방지한다.

### `데이터 레이스`

데이터 레이스는 여러 철학자가 동시에 공유 자원에 접근할 때 경쟁 상태(Race Condition)가 발생할 수 있는 문제이다.

### `데이터 레이스 방지`

- 이를 방지하기 위해 공유 자원(철학자의 식사 시간, 각 포크의 상태, 철학자가 죽었는지 여부, 출력 메시지 동기화)에 뮤텍스를 사용해 안전하게 보호하여 상호 배제(Mutual Exclusion)을 보장하여 방지한다.

<br>

## ✏️ Review

- 동시성 프로그래밍에서 발생하는 동기화 문제와 이를 해결하는 방법을 배울 수 있었습니다.
- 여러 스레드, 프로세스가 동시에 실행되며 공유 자원에 접근할 때 발생하는 데이터 레이스 문제를 다루며 충돌을 방지하는 동기화 기법(뮤텍스, 세마포어 등)들을 배울 수 있었습니다.
- 이러한 동기화 기법을 사용할 때 발생할 수 있는 대표적인 문제인 데드락 발생조건과 방지방법 들을 실습을 통해 배울 수 있었습니다.
